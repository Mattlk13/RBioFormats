<!-- rmarkdown v1 -->
<!--
%\VignetteIndexEntry{R interface to the Bio-Formats library}
%\VignettePackage{RBioFormats}
%\VignetteEngine{knitr::knitr}
-->

```{r style, echo = FALSE, results = 'asis'}
BiocStyle::markdown()
```

# RBioFormats: an R interface to the Bio-Formats library

## Basic use

```{r library, message=FALSE}
library("RBioFormats")
library("EBImage")
library("methods")
```

Read a greyscale image

```{r readgrey}
f = system.file("images", "sample.png", package = "EBImage")

img = read.image(f)
img
```

or an RGB image

```{r readrgb}
f = system.file("images", "sample-color.png", package = "EBImage")

img = read.image(f)
img
```

To print just the dimension order use
```{r dimorder}
dimorder(img)
```

Loading images using `r Githubpkg('aoles/RBioFormats')` should give the same results as using the `r Biocpkg('EBImage')` package.

```{r comparewithref}
identical(readImage(f), as.Image(img))
```

## The BFImage class

`r Rpackage('RBioFormats')` stores image data in an *BFImage* class which extends the *Image* class from `r Biocpkg('EBImage')`.

```{r classdef}
getClassDef("BFImage")
```

Compared to the original *Image* class it features two additional slots containing image metadata: the `metadata` slot which holds the metadata organized in three sublists, namely coreMetadata, globalMetadata and seriesMetadata, and the OME-XML DOM tree representation of the metadata in the `omexml` slot.

## Working with metadata

Use the `read.metadata` function to read the image metadata without loading the pixel data.

```{r read.metadata}
f = system.file("images", "nuclei.tif", package = "EBImage")
metadata = read.metadata(f)

str(metadata)
```

Some core metadata which is guaranteed to exist for any image type is stored in `coreMetadata`.

```{r coreMetadata}
img = read.image(f)

names(coreMetadata(img))
```

The `globalMetadata` and `seriesMetadata` are format-specific.

```{r globalMetadata}
str(globalMetadata(img))
```

The OME-XML metadata can be accessed using tools from the `r CRANpkg('XML')` package.

```{r parseXML, message=FALSE}
require("XML")

xml = xmlTreeParse(img@omexml)
xmlRoot(xml)
```

For details on working with XML data in R see the `r Rpackage('XML')` package [documentation](http://www.omegahat.org/RSXML/ "XML package documentation").

## Performance relative to *EBImage*

```{r benchmark, message=FALSE, eval=FALSE}
require("microbenchmark")
microbenchmark(read.image(f), readImage(f), times = 10)
```

## Working with test images

For development purposes it is useful to have images of a specific size or pixel type for testing. Mock files containing gradient images can be generated using

```{r mockFile, out.width='256px', out.height='256px'}
f = mockFile(sizeX = 256, sizeY = 256)
img = read.image(f)
display(img, method = "raster")
```

Note that the native image data range is different depending on pixel type:

```{r defaultRange, echo=FALSE, results='asis', R.options=list(digits = 15)}
FormatTools = J("loci.formats.FormatTools")
types = c("int8", "uint8", "int16", "uint16", "int32", "uint32", "float", "double")

ranges = sapply(types, function(t) {
  minmax = FormatTools$defaultMinMax(FormatTools$pixelTypeFromString(t))
  setNames(minmax, c("min", "max"))
  })
knitr::kable(ranges)
```

Image data returned by `r Rpackage('RBioFormats')` is by default scaled to the [0:1] range. This behavior can be controlled using the `normalize` argument to `read.image`.

```{r range}
sapply(types, function(t) {
  img = read.image(mockFile(sizeX = 65536, sizeY = 11, pixelType = t), normalize = FALSE)
  setNames(range(img), c("min", "max"))  
})
```
